= Testing Smart Contracts

In a blockchain environment, a single mistake could cost you all of your funds - or even worse, your users'!. This guide will help you develop robust applications by writing automated tests that verify your application behaves exactly as you intended.

We'll cover the following topics:

 * <<setting-up-a-testing-environment, Setting up a Testing Environment>>
 * <<writing-unit-tests, Writing Unit Tests>>
 * <<performing-complex-assertions, Performing Complex Assertions
 * Best Smart Contract Testing Practices

=== About Testing

There is a a wide range of testing techniques, from xref:interact.adoc[simple manual verifications] to complex end-to-end setups, all of them useful in their own way.

When it comes to smart contract development though, practice has shown that https://en.wikipedia.org/wiki/Unit_testing[_contract unit testing_] is exceptionally worthwhile. These tests are simple to write and and quick to run, and let you add features and fix bugs in your code with confidence.

Smart contract unit testing consists of multiple small, focused tests, which each check a small part of your contract for correctness. They can often be expressed in single sentences that make up a specification, such as 'the admin is able to pause the contract', 'transferring tokens emits an event' or 'non-admins cannot mint new tokens'.

[[setting-up-a-testing-environment]]
== Setting up a Testing Environment

You may be wondering _how_ we're going to run these tests, since smart contracts are executed inside a blockchain. Using the actual Ethereum network would be very expensive, and while testnets are free, they are also slow (with blocktimes between 5 and 15 seconds). If we intend to run hundreds of tests whenever we make a change to our code, we need something better.

What we will use is called a _local blockchain_: a slimmed down version of the real thing, disconnected from the Internet, running on your machine. This will simplify things quite a bit: you won't need to go get Ether, and you won't have to wait for blocks to be mined.

To aid us in this we'll use the https://github.com/OpenZeppelin/openzeppelin-test-environment#readme[*OpenZeppelin Test Environment*], a JavaScript library that will take care of setting up our local blockchain.

TIP: If you've read the xref:interact.adoc['Interacting with Your Contracts' guide], you will already be familiar with https://github.com/trufflesuite/ganache-cli/[Ganache]. Test Environment works in a similar way, but is much easier to use.

To install the OpenZeppelin Test Environment, run:

```bash
$ npm install --save-dev @openzeppelin/test-enviroment
```

Once you `require` the library from your JavaScript code, it will automatically run a local testing blockchain for you. It also exports variables and functions related to this environment, such as a list of `accounts` that have been pre-funded with Ether, and convenient ways to load your contracts from their compiled artifacts.

```javascript
const { accounts, contract } = require('@openzeppelin/test-environment#readme');

// Use the different accounts, which are unlocked and funded with Ether
const [ admin, deployer, user ] = accounts;

// Create a contract object from a compilation artifact
const MyContract = contract.fromArtifact('MyContract');
```

For detailed information on these exported values and their usage, refer to Test Environment's https://github.com/OpenZeppelin/openzeppelin-test-environment/blob/master/docs/modules/ROOT/pages/api.adoc[API reference].

[[writing-unit-tests]]
== Writing Unit Tests

In order to actually run your tests, you will need to also install a JavaScript _test runner_. You are free to use any of the https://github.com/OpenZeppelin/openzeppelin-test-environment/blob/master/docs/modules/ROOT/pages/setup.adoc#test-runners[recommended ones]: for this guide, we'll pick https://mochajs.org/[Mocha] with https://www.chaijs.com/[Chai] assertions.

```bash
$ npm install --save-dev mocha chai
```

Create a `test` directory: this is where you will keep your test files. These are best structured by mirroring xref:write-contracts#setting-up-a-solidity-project[the `contracts` directory]: for each `.sol` file there, create a corresponding `.test.js` file.

Time to write our first tests! These will test properties of the `SetAndGet` contract xref:write-contracts#set-and-get-contract[from previous guides].

```javascript
// Load dependencies
const { accounts, contract } = require('@openzeppelin/test-environment');
const { expect } = require('chai');

// Load compiled artifacts
const SetAndGet = contract.fromArtifact('SetAndGet');

// Start test block
describe('SetAndGet', function () {
  const [ owner ] = accounts;

  beforeEach(async function () {
    // Deploy a new contract for each test
    this.contract = await SetAndGet.new({ from: owner });
  });

  // Test case
  it('get returns a value previously set', async function () {
    // Set a value
    await this.contract.set(42, { from: owner });

    // Test the returned value is the same one - values from the blockchain are
    // often read as strings
    expect((await this.contract.get()).toString()).to.equal('42');
  });
});
```

TIP: Many books have been written about how to structure unit tests: for a quick reference, check out the https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/test[tests for OpenZeppelin Contracts], or the following https://medium.com/coinmonks/how-to-test-ethereum-smart-contracts-ac28fa852281[guide for ERC20 tests].

We are now ready to run our tests! The best way to do this is by adding a `test` script to your `package.json`:

[source,diff]
----
 'scripts': {
+  'test': 'mocha --exit --recursive test'
 }
----

With this, running `npm test` will execute all tests in the `test` directory, checking that your contracts work the way you meant them too.

TIP: Don't forget to re-compile your contracts if you make changes to them!

It's also a very good idea at this point to set up a Continuous Integration service such as https://circleci.com/[CircleCI] to make your tests run automatically every time you commit your code to GitHub.

[[performing-complex-assertions]]
== Performing Complex Assertions

Many interesting properties of your contracts can be hard to capture with JavaScript primitives, such as:

 * verifying that the contract reverts on errors
 * measuring by how much an account's Ether balance changed
 * validating the values of emitted events

https://github.com/OpenZeppelin/openzeppelin-test-helpers#readme[*OpenZeppelin Test Helpers*] is a library designed to help you test all of these properties. It will also let you simulate time passing on the blockchain, handle very large numbers, and have easy access to common constants.

Begin by installing it:

```bash
$ npm install --save-dev @openzeppelin/test-helpers
```

Because Test Environment will detect this installation and configure it for you, we can get started using the library right away:

```javascript
const { accounts, contract } = require('@openzeppelin/test-environment');
const { expectEvent, expectRevert } = require('@openzeppelin/test-helpers');
const { expect } = require('chai');

const SetAndGet = contract.fromArtifact('SetAndGet');

describe('SetAndGet', function () {
  const [ owner, other ] = accounts;

  beforeEach(async function () {
    this.contract = await SetAndGet.new({ from: owner });
  });

  it('get returns a value previously set', async function () {
    await this.contract.set(42, { from: owner });

    // Use large integer comparisons
    expect(await this.contract.get()).to.be.bignumber.equal('42');
  });

  it('set emits an event', async function () {
    const receipt = await this.contract.set(42);

    // Test that a ValueChanged event was emitted with the new value
    expectEvent(receipt, 'ValueChanged', { newValue: 42 });
  });

  it('non owner cannot set new value', async function () {
    // Test the transaction reverts
    await expectRevert(
      this.contract.set(42, { from: other }),
      'Ownable: caller is not the owner'
    );
  });
});
```

The Test Helpers are very useful, and will let you write powerful assertions without having to worry about the low-level details of the underlying Ethereum libraries. To learn more about what you can do with them, head to their https://github.com/OpenZeppelin/openzeppelin-test-helpers#reference[API reference].

== Next Steps

Once you have thoroughly tested your contracts and are reasonably sure of their correctness, you'll want to deploy them to a real network and start interacting with them. The following guides will get you up to speed on these topics:

 * xref:public-staging.adoc[Deploy contracts to a public network]
 * xref:interact.adoc[Interact with your deployed contracts]
