= Deploying and Interacting with Smart Contracts

Unlike most software, smart contracts don't run on your computer or somebody's server: they live on the Ethereum network itself. This means that interacting with them is a bit different from more traditional applications.

This guide will cover all you need to know to get you started using your contracts, including:

 * <<deploying-a-smart-contract, Deploying a Smart Contract>>
 * <<interacting-via-the-cli, Interacting from the Terminal>>
 * <<performing-complex-assertions, Interacting Programatically>>

[[local-blockchain]]
== Using a Local Blockchain

The Ethereum blockchain (often called 'mainnet', for 'main network') requires spending real money to use it, in the form of Ether (its native currency). This makes it a poor choice when trying out new ideas or tools.

To solve this, a number of 'testnets' (for 'test networks') exist: these include the Ropsten, Rinkeby and Kovan blockchains. They work very similarly to mainnet, with one key difference: you can get Ether for these networks for free, so that using them doesn't cost you a single cent. However, you will still need to deal with private key management, blocktimes in the range of 5 to 20 seconds, and actually getting this free Ether. And of course, an Internet connection.

During development, it is often a great idea to instead use a _local_ blockchain. It will run on your machine, requiring no Internet access, provide you with all the Ether that you need, and mine blocks instantly. These reasons will also make local blockchains a great match for xref:unit-testing.adoc#setting-up-a-testing-environment[automated tests].

TIP: If you want to learn how to deploy and use contracts on a _public_ blockchain, like the Ethereum testnets, head to our xref:public-staging.adoc[Using Public Networks] guide.

The most popular local blockchain is called https://github.com/trufflesuite/ganache-cli/[Ganache]. To install it on your project, run:

```bash
$ npm install --save-dev ganache-cli
```

By default, Ganache will create a random set of unlocked accounts and give them Ether. In order to get the same addresses that will be used in this guide, you can start Ganache in deterministic mode:

```
$ npx ganache-cli --deterministic
```

Ganache will print out a list of available accounts and their private keys, along with some blockchain configuration values. Most importantly, it will display its address, which we will use to connect to it. By default, this will be `127.0.0.1:8545`.

Something to keep in mind is that every time you run Ganache, it will create a brand new local blockchain - the state of previous runs is **not** preserved. This is fine for our short-lived experiments, but it means that you will need to have a window open running Ganache for the duration of this guide. Alternatively, you can run Ganache with the `--db` option, providing a directory to store its data inbetween runs.

NOTE: As an alternative to Ganache, you can also run an actual Ethereum node in _https://geth.ethereum.org/getting-started/dev-mode[development] https://wiki.parity.io/Private-development-chain[mode]_. These are a bit more complex to set up, and not as flexible for testing and development, but are more representative of the real network than Ganache.

[[getting-started-with-the-cli]]
== Getting Started with the OpenZeppelin CLI

The low-level details of deploying and interacting with contracts are quite involved, but you won't need to worry about them: the https://docs.openzeppelin.com/sdk/2.6/[*OpenZeppelin command-line interface (CLI)*] will take care of these processes for you.

You may have used the CLI already to xref:writing-smart-contracts.adoc#compiling-solidity-source-code[compile your contracts] - if not, install it now:

```bash
$ npm install --save-dev @openzeppelin/cli
```

In order to track your deployed contracts and connect to different networks, the CLI needs to be initialized in your project. Do so now, and provide it with a name and version number for your project when prompted:

```bash
$ npx oz init
```

Two things will happen during initialization. First, an `.openzeppelin` directory will be created, holding project-specific information. This directory will be managed by the CLI: you won't need to manually edit anything. It is important however to commit any changes here to your Git repository.

Second, the CLI will store network configuration in a file called `networks.js`. For convenience, it is already populated with an entry called `development`, with configuration matching <<local-blockchain, Ganache>>'s default.

Let's use our first CLI commands to get acquainted with it. We'll begin by querying Ganache for all unlocked accounts:

```bash
$ npx oz accounts
```

Unlike `init` and `compile`, the `accounts` command requires a network to run on: the CLI will pick up the entries on the `networks.js` file and prompt you to select one from that list.

Once you choose `development`, the entry for Ganache, it will print out all available accounts there:

```bash
? Pick a network development
Accounts for dev-1576250059363:
Default: 0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1
All:
- 0: 0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1
- 1: 0xFFcf8FDEE72ac11b5c542428B35EEF5769C409f0
...
```

We can also query the balance of these accounts by using the `balance` command:

```bash
$ npx oz balance
? Enter an address to query its balance 0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1
? Pick a network development
Balance: 100 ETH
```

This shows why using a local blockchain is so convenient: Ganache has prefunded all of our accounts with 100 Ether, which means we'll be able to send plenty of transactions!

[[deploying-a-smart-contract]]
== Deploying a Smart Contract

With the <<getting-started-with-the-cli, CLI setup complete>>, we're now ready to deploy a contract. We'll be deploying `Box`, from the xref:writing-smart-contracts.adoc#setting-up-a-solidity-project[Writing Smart Contracts guide]. Make sure you have a copy stored in `contracts/Box.sol`:

```solidity
// contracts/Box.sol
pragma solidity ^0.5.0;

contract Box {
    uint256 private value;

    // Emitted when the stored value changes
    event ValueChanged(uint256 newValue);

    // Stores a new value in the contract
    function store(uint256 newValue) public {
        value = newValue;
        emit ValueChanged(newValue);
    }

    // Reads the last stored value
    function retrieve() public view returns (uint256) {
        return value;
    }
}
```

The OpenZeppelin CLI will guide you through the deployment process, asking for information as needed. Using the `create` command, deploy the `Box` contract to the `development` network (<<local-blockchain, Ganache>>), replying 'no' when prompted to initialize:

```bash
$ npx oz create
✓ Compiled contracts with solc 0.5.9
? Pick a contract to instantiate Box
? Pick a network development
✓ Contract Box deployed
All contracts have been deployed
? Call a function to initialize the instance after creating it? No
✓ Setting everything up to create contract instances
✓ Instance created at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
```

All done! On a real network this process would've taken a couple seconds, but it is instant on local blockchains.

TIP: If you got a connection error, make sure you are <<local-blockchain, running Ganache>> in another terminal.

The CLI will keep track of your deployed contracts, but it also displays their addresses after deployment (in our example, `0xCfEB869F69431e42cdB54A4F4f105C19C080A601`). These values will be useful when interacting with them programatically.

NOTE: Remember that local blockchains **do not** persist their state throughout multiple runs! If you close your Ganache process, you'll have to re-deploy your contracts.

[[interacting-via-the-cli]]
== Interacting via the CLI

With our `Box` contract <<deploying-a-smart-contract, deployed>>, we can start using it right away from the <<getting-started-with-the-cli, CLI>>.


=== Sending Transactions

`Box` 's first function, `store`, receives an integer value and stores it on the contract storage. Because this function _modifies_ the blockchain state, we need to _send a transaction_ to the contract to execute it.

This can be achieved with the CLI's `send-tx` command. Choose your `Box` contract when prompted by the CLI, and select the `store` function, with whatever value you want to send.

```bash
$ npx oz send-tx
? Pick a network development
? Pick an instance Box at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function store(newValue: uint256)
? newValue (uint256): 5
✓ Transaction successful. Transaction hash: 0xe2f6d0f14719c1ec4eadcb9addef5661326e0adda5f2072ec6e1cc87d113c393
Events emitted:
 - ValueChanged(5)
```

Note how `send-tx` also detected that `Box` emitted a `ValueChanged` event with our newly stored value.

=== Querying State

`Box` 's other function is called `retrieve`, and it returns the integer value stored in the contract. This is a _query_ of blockchain state, so we don't need to send a transaction: a static _call_ will suffice.

You may have noticed `send-tx` didn't include `retrieve` in the list of functions to run: this is because queries are run using the `call` command instead:

```bash
$ npx oz call
? Pick a network development
? Pick an instance Box at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function retrieve()
✓ Method 'retrieve()' returned: 5
```

Because `call` doesn't send a transaction, there is no transaction hash to report. This also means that using `call` doesn't cost any Ether, and can be used for free on any network.

TIP: To learn more about `send-tx` and `call`, check out the https://docs.openzeppelin.com/sdk/2.6/api/cli[CLI API reference].

[[interacting-programatically]]
== Interacting Programatically

from sdk interacting guide (https://docs.openzeppelin.com/sdk/2.6/interacting#setup)

replace manual setup with contract loader?

send tx, call function, same as CLI guide


== closing thoughts ???

this was was like testing, but manual and not very complete. automated is better.

next steps:
    - automated testing
    - deploying on public testnets
