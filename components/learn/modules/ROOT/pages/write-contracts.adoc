= Write Solidity Contracts

Welcome to the exciting world of smart contract development! This guide will let you get started writing Solidity contracts by going over the following:

 * <<setting-up-a-solidity-project, Setting up a Solidity Project>>
 * <<compiling-solidity-source-code, Compiling Solidity Source Code>>
 * <<multi-file-projects, Multi-File Projects>>
 * <<using-openzeppelin-contracts, Using the OpenZeppelin Contracts library>>

=== About Solidity

We won't cover language concepts such as syntax or keywords in this guide. For that, you'll want to check out the following curated content, which feature great learning resources for both newcomers and experienced developers:

 * For a general overview of how Ethereum and smart contracts work, the official website hosts a https://ethereum.org/learn/[Learn about Ethereum] section with lots of beginner-friendly content
 * If you're new to the language, the https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html[official Solidity documentation] is a good resource to have handy. Take a look at their https://solidity.readthedocs.io/en/latest/security-considerations.html[security recommendations], which nicely go over the differences between blockchains and traditional software platforms
 * These https://consensys.github.io/smart-contract-best-practices/[best practices] are quite extensive, and include both https://consensys.github.io/smart-contract-best-practices/recommendations/[proven patterns] to learn from and https://consensys.github.io/smart-contract-best-practices/known_attacks/[known pitfalls] to avoid
 * The https://solidity-05.ethernaut.openzeppelin.com/[Ethernaut] web-based game will have you look for subtle vulnerabilities in smart contracts as you advance through levels of increasing difficulty

With that out of the way, let's get started!

[[setting-up-a-solidity-project]]
== Setting up a Solidity Project

The first step in any project is to create a `contracts` directory, which is where you will store your Solidity source files (`.sol`). This is equivalent to the `src` directory you may be familiar with from other languages.

We can now write our first simple smart contract:

```solidity
pragma solidity ^0.5.0;

contract SetAndGet {
    uint256 private value;

    // Emitted when the stored value changes
    event ValueChanged(uint256 newValue);

    // Stores a new value in the contract
    function set(uint256 newValue) public {
      value = newValue;

      emit ValueChanged(newValue);
    }

    // Reads the last stored value
    function get() public view returns (uint256) {
      return value;
    }
}
```

We will store it in `contracts/StoreAndGet.sol`. Each `.sol` file should have the code for a single contract, and be named after it.

[[compiling-solidity-source-code]]
== Compiling Solidity Source Code

The Ethereum Virtual Machine (EVM) cannot execute Solidity code directly: we first need to compile it into EVM bytecode.

To do so, we'll use the https://docs.openzeppelin.com/sdk/2.6/[*OpenZeppelin command-line interface (CLI)*]:

```bash
$ npm install --save-dev @openzeppelin/cli
```

The CLI is quite powerful, and it is the entry point to many exciting features (such as upgradeable smart contracts and interactive transactions!). We will come back to it often.

For now however, let's focus on compiling. This can be achieved by running a single command:

```bash
$ npx oz compile
```

NOTE: If you're unfamiliar with the `npx` command, check out our https://example.com[project setup guide].

The `compile` command will automatically look for all contracts in the `contracts` directory, and compile them using the Solidity compiler version that best suits your project.

You will notice a `build/contracts` directory was created: it holds the compiled artifacts (bytecode and metadata), which are `.json` files. It's a good idea to add this directory to your `.gitignore`.

You can also configure your compilation, which includes choosing a compiler version and enabling optimizations, by passing arguments to the `compile` command:

```bash
$ npx oz compile --solc-version=0.5.12 --optimizer on
```

For detailed information on these options, refer to the https://docs.openzeppelin.com/sdk/2.6/api/cli#compile[`compile` API reference].

[[multi-file-projects]]
== Multi-File Projects

There are multiple reasons that cause most projects to have multiple Solidity source files: from modularization via https://solidity.readthedocs.io/en/latest/contracts.html#inheritance[inheritance] to complex multi-contract systems.

Because the compiler will pick up all files in the `contracts` directory and subdirectories, you are free to organize your code as you see fit (such as having subdirectories for `access-control` or `token` contracts).

To import a contract from another file, refer to it by its relative path using an `import` statement:

```solidity
import './Math.sol'; // Import from the same directory
import './access-control/Admin.sol'; // Import from a subdirectory
```

[[using-openzeppelin-contracts]]
== Using the OpenZeppelin Contracts Library

Reusable modules and libraries are the cornerstone of great software. The https://openzeppelin.com/contracts/[*OpenZeppelin Contracts*] library contains lots of useful building blocks for smart contracts to build on. And you can rest easy: they've been the subject of multiple security audits, with their security and correctness battle-tested.

To use the library, you'll first need to download it from the latest published release:

```bash
$ npm install --save-dev @openzeppelin/contracts
```

NOTE: You should always use the library from these published releases: copy-pasting library source code into your project makes it very easy to introduce security vulnerabilities in your contracts.

To use one of the OpenZeppelin Contracts, `import` its path with `@openzeppelin/contracts`.

Let's see how limiting access control to our `SetAndGet` contract looks like:

[[set-and-get-contract]]
```solidity
pragma solidity ^0.5.0;

// The Ownable contract will make the account that deploys a contract its owner,
// giving it special permissions.
import '@openzeppelin/contracts/ownership/Ownable.sol';

contract SetAndGet is Ownable { // Inherit from the Ownable contract
    uint256 private value;

    event ValueChanged(uint256 newValue);

    // Stores a new value in the contract
    function set(uint256 newValue) public onlyOwner { // Restrict access to set
      value = newValue;

      emit ValueChanged(newValue);
    }

    // Reads the last stored value
    function get() public view returns (uint256) {
      return value;
    }
}
```

Despite the OpenZeppelin Contracts not being located in your `contracts` directory, the CLI is smart enough to know where to look for them while compiling.

=== More on OpenZeppelin Contracts

The https://docs.openzeppelin.com/contracts/2.x/#next-steps[OpenZeppelin Contracts documentation] is a great place to learn about developing secure smart contract systems. It features both guides and a detailed API reference: see for example the https://docs.openzeppelin.com/contracts/2.x/access-control[Access Control guide] to know more about the `Ownable` contract used in the code sample above.

While the library is designed in such a way that it is difficult to misuse it, when in doubt you can always refer to the documentation for clarification.

== Next Steps

Writing and compiling Solidity contracts are but the first steps in the journey to having your decentralized application running on the Ethereum network. Once you are confortable with this setup, you'll want to move on to more advanced tasks:

 * xref:unit-testing.adoc[Perform automated contract testing]
 * xref:interact.adoc[Interact with your deployed contracts]
 * xref:public-staging.adoc[Deploy contracts to a public network]
